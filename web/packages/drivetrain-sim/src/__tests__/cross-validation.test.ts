/**
 * Cross-validation tests: Verify TypeScript matches Python implementation.
 *
 * These tests read from shared/test-vectors.json which is generated by:
 *   python scripts/generate_test_vectors.py
 *
 * The test vectors file contains expected values computed by Python.
 * This test validates that TypeScript produces identical results.
 *
 * Run with: npm test
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import { WillisConstraint, GearRatioConstraint } from '../core/constraints';
import { PlanetaryGearComponent } from '../components/planetary';
import { VehicleComponent } from '../components/vehicle';

// Load test vectors from shared file
interface TestCase {
  id: string;
  description: string;
  input: Record<string, number>;
  expected: Record<string, number | null>;
}

interface TestSuite {
  description: string;
  test_cases: TestCase[];
  vehicle_params?: Record<string, number>;
}

interface TestVectors {
  version: string;
  generated_at: string | null;
  tolerance: { default: number; integration: number };
  test_suites: Record<string, TestSuite>;
}

let testVectors: TestVectors;
let tolerance: number;

beforeAll(() => {
  // Load test vectors - path relative to this test file
  // From: web/packages/drivetrain-sim/src/__tests__ -> gearbox/shared
  const vectorsPath = join(__dirname, '../../../../../shared/test-vectors.json');
  const content = readFileSync(vectorsPath, 'utf-8');
  testVectors = JSON.parse(content);
  tolerance = testVectors.tolerance.default;

  // Verify test vectors have been generated
  if (testVectors.generated_at === null) {
    throw new Error(
      'Test vectors have not been generated. Run: python scripts/generate_test_vectors.py'
    );
  }
});

describe('cross-validation (shared test vectors)', () => {
  describe('Willis Equation', () => {
    it('should match Python for all test cases', () => {
      const suite = testVectors.test_suites.willis_equation;

      for (const tc of suite.test_cases) {
        const { rho, omega_carrier, omega_ring } = tc.input;
        const expected = tc.expected.omega_sun;

        if (expected === null) {
          throw new Error(`Test case ${tc.id} has no expected value`);
        }

        const constraint = new WillisConstraint({
          sunPort: 'sun',
          carrierPort: 'carrier',
          ringPort: 'ring',
          rho,
        });

        const actual = constraint.calcSunSpeed(omega_carrier, omega_ring);

        expect(actual).toBeCloseTo(expected, 10);
      }
    });
  });

  describe('Torque Ratios', () => {
    it('should match Python for all test cases', () => {
      const suite = testVectors.test_suites.torque_ratios;

      for (const tc of suite.test_cases) {
        const { rho } = tc.input;
        const { sun_ratio, carrier_ratio, ring_ratio } = tc.expected;

        if (sun_ratio === null || carrier_ratio === null || ring_ratio === null) {
          throw new Error(`Test case ${tc.id} has null expected values`);
        }

        const constraint = new WillisConstraint({
          sunPort: 'sun',
          carrierPort: 'carrier',
          ringPort: 'ring',
          rho,
        });

        const [actualSun, actualCarrier, actualRing] = constraint.getTorqueRatios();

        expect(actualSun).toBeCloseTo(sun_ratio, 10);
        expect(actualCarrier).toBeCloseTo(carrier_ratio, 10);
        expect(actualRing).toBeCloseTo(ring_ratio, 10);
      }
    });
  });

  describe('Inertia Coefficients', () => {
    it('should match Python for all test cases', () => {
      const suite = testVectors.test_suites.inertia_coefficients;

      for (const tc of suite.test_cases) {
        const { rho, j_sun } = tc.input;
        const { j_cc, j_cr, j_rr } = tc.expected;

        if (j_cc === null || j_cr === null || j_rr === null) {
          throw new Error(`Test case ${tc.id} has null expected values`);
        }

        const constraint = new WillisConstraint({
          sunPort: 'sun',
          carrierPort: 'carrier',
          ringPort: 'ring',
          rho,
        });

        // TypeScript returns normalized coefficients, multiply by j_sun
        const coeffs = constraint.getInertiaCoefficients();
        const actualJcc = coeffs.carrierCarrier * j_sun;
        const actualJcr = coeffs.carrierRing * j_sun;
        const actualJrr = coeffs.ringRing * j_sun;

        expect(actualJcc).toBeCloseTo(j_cc, 10);
        expect(actualJcr).toBeCloseTo(j_cr, 10);
        expect(actualJrr).toBeCloseTo(j_rr, 10);
      }
    });
  });

  describe('Gear Ratio Transformations', () => {
    it('should match Python for all test cases', () => {
      const suite = testVectors.test_suites.gear_ratio;

      for (const tc of suite.test_cases) {
        const { ratio, efficiency, omega_in, torque_out, j_out } = tc.input;
        const { omega_out, torque_in, j_reflected } = tc.expected;

        if (omega_out === null || torque_in === null || j_reflected === null) {
          throw new Error(`Test case ${tc.id} has null expected values`);
        }

        const constraint = new GearRatioConstraint({
          inputPort: 'input',
          outputPort: 'output',
          ratio,
          efficiency,
        });

        const actualOmegaOut = constraint.transformSpeed(omega_in);
        const actualTorqueIn = constraint.transformTorque(torque_out);
        const actualJReflected = constraint.getReflectedInertia(j_out);

        expect(actualOmegaOut).toBeCloseTo(omega_out, 10);
        expect(actualTorqueIn).toBeCloseTo(torque_in, 10);
        expect(actualJReflected).toBeCloseTo(j_reflected, 10);
      }
    });
  });

  describe('Road Load', () => {
    it('should match Python for all test cases', () => {
      const suite = testVectors.test_suites.road_load;
      const vp = suite.vehicle_params!;

      const vehicle = new VehicleComponent(
        {
          mEmpty: vp.m_empty,
          mPayload: vp.m_payload,
          rWheel: vp.r_wheel,
          aFrontal: vp.a_frontal,
          cD: vp.c_d,
          cR: vp.c_r,
          rhoAir: vp.rho_air,
          g: vp.g,
        },
        vp.payload_fraction
      );

      for (const tc of suite.test_cases) {
        const { velocity, grade } = tc.input;
        const { f_total, t_wheel } = tc.expected;

        if (f_total === null || t_wheel === null) {
          throw new Error(`Test case ${tc.id} has null expected values`);
        }

        const actualFTotal = vehicle.calcTotalRoadLoad(velocity, grade);
        const actualTWheel = vehicle.calcWheelTorqueDemand(velocity, grade);

        // Use slightly lower precision for road load due to trig functions
        expect(actualFTotal).toBeCloseTo(f_total, 4);
        expect(actualTWheel).toBeCloseTo(t_wheel, 4);
      }
    });
  });

  describe('Torque Split', () => {
    it('should match Python for all test cases (efficiency disabled)', () => {
      const suite = testVectors.test_suites.torque_split;

      for (const tc of suite.test_cases) {
        const { z_sun, z_ring, t_carrier } = tc.input;
        const { t_sun, t_ring, balance_error } = tc.expected;

        if (t_sun === null || t_ring === null || balance_error === null) {
          throw new Error(`Test case ${tc.id} has null expected values`);
        }

        const planetary = new PlanetaryGearComponent(
          { zSun: z_sun, zRing: z_ring, useEfficiency: false },
          'planetary'
        );

        // Disable efficiency to match Python exactly
        const [actualTSun, actualTRing] = planetary.calcTorqueSplit(t_carrier, false);
        const actualBalance = actualTSun + t_carrier + actualTRing;

        expect(actualTSun).toBeCloseTo(t_sun, 10);
        expect(actualTRing).toBeCloseTo(t_ring, 10);
        expect(Math.abs(actualBalance)).toBeLessThan(1e-10);
      }
    });
  });

  describe('Test Vectors Metadata', () => {
    it('should have valid version', () => {
      expect(testVectors.version).toBeDefined();
      expect(testVectors.version).toMatch(/^\d+\.\d+\.\d+$/);
    });

    it('should have generation timestamp', () => {
      expect(testVectors.generated_at).not.toBeNull();
    });

    it('should have all test suites', () => {
      const expectedSuites = [
        'willis_equation',
        'torque_ratios',
        'inertia_coefficients',
        'gear_ratio',
        'road_load',
        'torque_split',
      ];

      for (const suite of expectedSuites) {
        expect(testVectors.test_suites[suite]).toBeDefined();
      }
    });
  });
});

// Summary test that reports all results
describe('cross-validation summary', () => {
  it('reports total test coverage', () => {
    let totalTests = 0;
    for (const [name, suite] of Object.entries(testVectors.test_suites)) {
      if ('test_cases' in suite) {
        totalTests += suite.test_cases.length;
      }
    }

    console.log(`\nðŸ“Š Cross-validation: ${totalTests} test cases validated against Python`);
    console.log(`   Generated: ${testVectors.generated_at}`);
    console.log(`   Tolerance: ${testVectors.tolerance.default}`);

    expect(totalTests).toBeGreaterThan(0);
  });
});
